<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <meta name="robots" content="noindex" />
  <title>Puzzel Chat Widget (Puzzel-only)</title>
  <style>
    html,body{margin:0;padding:0;width:100%;height:100%;overflow:hidden;background:#f5f7fa;}
    #pzl-widget-container{position:relative;width:100%;height:100vh;}
    iframe{position:absolute;top:0;left:0;width:100% !important;height:100% !important;border:none;}
    #loading-overlay{
      position:fixed;top:0;left:0;width:100%;height:100%;
      background:linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      z-index:10000;display:none;align-items:center;justify-content:center;
      transition:opacity 0.5s ease-out;
    }
    #loading-overlay.active{display:flex;}
    #loading-overlay.fade-out{opacity:0;pointer-events:none;}
    .loading-content{
      text-align:center;padding:40px;background:rgba(255,255,255,0.98);
      border-radius:16px;box-shadow:0 20px 60px rgba(0,0,0,0.3);
      max-width:400px;
    }
    .logo-container{margin-bottom:24px;}
    .logo-container img{height:60px;width:auto;}
    .spinner{
      width:48px;height:48px;margin:0 auto 20px;
      border:4px solid rgba(102,126,234,0.2);border-top-color:#667eea;
      border-radius:50%;animation:spin 1s linear infinite;
    }
    @keyframes spin{to{transform:rotate(360deg);}}
    .status-text{
      font-family:system-ui,-apple-system,"Segoe UI",Roboto,Helvetica,Arial;
      font-size:16px;color:#2d3748;font-weight:500;
    }
    .status-subtext{
      font-family:system-ui,-apple-system,"Segoe UI",Roboto,Helvetica,Arial;
      font-size:13px;color:#718096;margin-top:8px;
    }
  </style>
</head>
<body>
  <div id="loading-overlay">
    <div class="loading-content">
      <div class="logo-container">
        <img src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRSH_LIxkik39VFHeFswzyPTAS087xo7Rr8LQ&s" alt="Puzzel">
      </div>
      <div class="spinner"></div>
      <div class="status-text" id="status">Initializing Puzzel...</div>
      <div class="status-subtext">Connecting to agent workspace</div>
    </div>
  </div>
  <div id="pzl-widget-container"></div>
  <script type="text/javascript" src="mousetrap.min.js"></script>
  <script type="text/javascript" src="puzzel-api.min.js"></script>
  <script>
  (function () {
    let CUSTOMER_ID = null;
    const CONTAINER_ID = "pzl-widget-container";
    const statusEl = document.getElementById("status");
    const loadingOverlay = document.getElementById("loading-overlay");
    let puzzelInitialized = false;
    let puzzelInfoData = null;
    let puzzelApi = null;
    let currentTokenHash = null;
    const TOKEN_CHECK_INTERVAL_MS = 5 * 60 * 1000; // Check every 5 minutes

    function simpleHash(str) {
      // Simple hash for comparison (not cryptographic)
      let hash = 0;
      for (let i = 0; i < str.length; i++) {
        const char = str.charCodeAt(i);
        hash = ((hash << 5) - hash) + char;
        hash = hash & hash;
      }
      return hash.toString();
    }

    async function refreshPuzzelToken(forceUpdate = false) {
      if (!puzzelApi || !puzzelInitialized) {
        console.warn("Cannot refresh token: Puzzel not initialized");
        return null;
      }

      try {
        const token = await puzzelApi.call("auth.getPuzzelIDAccessToken");
        if (!token) {
          console.warn("Token refresh returned empty token");
          return null;
        }

        const newTokenHash = simpleHash(token);

        // Check if token has changed
        if (!forceUpdate && currentTokenHash === newTokenHash) {
          console.log("Token check: unchanged at", new Date().toISOString());
          return token;
        }

        // Token is different, update claims
        const wasChanged = currentTokenHash !== null;
        currentTokenHash = newTokenHash;
        puzzelInfoData["auth.getPuzzelIDAccessToken"] = token;

        if (window.pzl && window.pzl.api && typeof window.pzl.api.setClaims === "function") {
          const chunkSize = 250;
          const tokenChunks = [];
          for (let i = 0; i < token.length; i += chunkSize) {
            tokenChunks.push(token.substring(i, i + chunkSize));
          }

          const claims = {
            agent_first_name: puzzelInfoData["agent.firstName"],
            agent_last_name: puzzelInfoData["agent.lastName"],
            puzzel_token_parts: tokenChunks.length.toString()
          };

          tokenChunks.forEach((chunk, index) => {
            claims[`puzzel_token_${index + 1}`] = chunk;
          });

          window.pzl.api.setClaims(claims);

          if (wasChanged) {
            console.log("ðŸ”„ Token CHANGED and claims updated at", new Date().toISOString());
            console.log("Token (first 50 chars):", token.substring(0, 50) + "...");
          } else {
            console.log("Token initialized at", new Date().toISOString());
          }
          return token;
        }
        return token;
      } catch (error) {
        console.error("Failed to refresh Puzzel token:", error);
        return null;
      }
    }

    function setupLinkInterception(api) {
      document.addEventListener("click", function(e) {
        const link = e.target.closest("a");
        if (!link || !link.href) {
          return;
        }

        const href = link.href;

        // Parse the URL to check for Puzzel KB article parameters
        let url;
        try {
          url = new URL(href);
        } catch (err) {
          return; // Invalid URL, let it be handled normally
        }

        const pzlRoute = url.searchParams.get("pzlRoute");
        const pzlArticleId = url.searchParams.get("pzlArticleId");

        // Only intercept links with pzlRoute=articleDetail and a pzlArticleId
        if (pzlRoute === "articleDetail" && pzlArticleId) {
          e.preventDefault();
          e.stopPropagation();

          const articleId = parseInt(pzlArticleId, 10);
          if (isNaN(articleId)) {
            console.error("Invalid pzlArticleId:", pzlArticleId);
            return;
          }

          // Try to get language from URL params, default to "en"
          const language = url.searchParams.get("language") || "en";

          async function openKbArticle() {
            try {
              // Get the current tab UID for context
              let relatedTabUid = '';
              try {
                const tabUidResult = await api.get('tab.uid');
                relatedTabUid = typeof tabUidResult === 'string' ? tabUidResult : String(tabUidResult || '');
              } catch (tabError) {
                // Ignore tab UID errors
              }

              console.log("Opening KB article:", articleId, "language:", language, "tabUid:", relatedTabUid);

              // Try the internal COPILOT_OPEN_ARTICLE event first (used by the widget internally)
              // This calls articleClicked() directly
              try {
                await api.call('events.publish', 'COPILOT_OPEN_ARTICLE', { 
                  data: { articleId: articleId, language: language }
                });
                console.log("Published COPILOT_OPEN_ARTICLE event");
                return;
              } catch (copilotError) {
                console.log("COPILOT_OPEN_ARTICLE failed, trying SYSTEM_KB_ARTICLE_SHOW:", copilotError);
              }

              // Fallback to SYSTEM_KB_ARTICLE_SHOW with reset
              try {
                await api.call('events.publish', 'SYSTEM_KB_TOP_ARTICLES_SHOW', { data: {} });
                await new Promise(resolve => setTimeout(resolve, 300));
              } catch (resetError) {
                // Ignore reset errors
              }

              const data = {
                articleId: articleId,
                language: language,
                tab: {
                  focus: true,
                  relatedTabUid: relatedTabUid
                }
              };

              await api.call('events.publish', 'SYSTEM_KB_ARTICLE_SHOW', { data });
            } catch (error) {
              console.error("Failed to open KB article:", error);
              window.open(href, '_blank', 'noopener,noreferrer');
            }
          }

          openKbArticle();
        }
        // All other links (including supsearch article-redirect URLs) open normally
      }, true);
    }

    async function main() {
      try {
        const maxWait = 5000;
        const startTime = Date.now();
        while (typeof widgetApiLib === "undefined" || typeof widgetApiLib.connect !== "function") {
          if (Date.now() - startTime > maxWait) {
            throw new Error("widgetApiLib.connect() not available. This page must be opened inside Puzzel.");
          }
          await new Promise(resolve => setTimeout(resolve, 100));
        }

        const api = await widgetApiLib.connect();
        puzzelApi = api;

        setupLinkInterception(api);

        const puzzelApis = [
          "agent.firstName",
          "agent.lastName",
          "agent.userName",
          "agent.displayName",
          "agent.contactCentreStatus",
          "agent.userStatus",
          "agent.allowLiveShare",
          "agent.currentProfile",
          "agent.canCall",
          "agent.outlineActiveElement",
          "agent.darkMode",
          "auth.userName",
          "auth.userId",
          "auth.customerKey",
          "auth.customerId",
          "auth.getPuzzelIDAccessToken"
        ];

        const results = await Promise.all(puzzelApis.map((k) => api.call(k).catch(() => undefined)));
        const puzzel_info = {};
        results.forEach((result, index) => {
          if (result !== undefined) {
            puzzel_info[puzzelApis[index]] = result;
          }
        });

        puzzelInfoData = puzzel_info;

        const customerIdValue = puzzel_info["auth.customerKey"];
        CUSTOMER_ID = customerIdValue != null ? String(customerIdValue) : null;

        if (!CUSTOMER_ID) {
          throw new Error("auth.customerId not available");
        }

        loadingOverlay.classList.add("active");
        statusEl.textContent = "Loading Puzzel chat widget...";

        const loader = document.createElement("script");
        loader.type = "text/javascript";
        loader.src = "https://app-cdn.puzzel.com/public/js/pzl_loader.js";
        loader.setAttribute("id", "pzlModuleLoader");
        const customerIdForLoader = CUSTOMER_ID === "192017" ? "99201" : CUSTOMER_ID;
        loader.setAttribute("data-customer-id", customerIdForLoader);
        loader.setAttribute("data-container", CONTAINER_ID);

        let widgetLoadError = null;
        let originalConsoleError = console.error;
        console.error = function(...args) {
          const errorMsg = args.join(' ');
          if (errorMsg.includes('pzl_loader abort bootstrap') ||
              errorMsg.includes('mapped configuration has no published version') ||
              errorMsg.includes('configVersion')) {
            widgetLoadError = errorMsg;
            statusEl.textContent = "Configuration Error";
            const subtext = document.querySelector(".status-subtext");
            if (subtext) {
              subtext.textContent = "Knowledgebase widget configuration missing published version. Please check Puzzel Agent settings.";
            }
          }
          originalConsoleError.apply(console, args);
        };

        loader.onload = function () {
          const checkPzlReady = setInterval(() => {
            if (window.pzl && window.pzl.api) {
              clearInterval(checkPzlReady);
              console.error = originalConsoleError;

              if (widgetLoadError) {
                console.warn("Widget loaded but configuration error detected:", widgetLoadError);
              }

              puzzelInitialized = true;

              if (typeof window.pzl.api.setClaims === "function") {
                const token = puzzelInfoData["auth.getPuzzelIDAccessToken"] || "";
                const chunkSize = 250;
                const tokenChunks = [];
                for (let i = 0; i < token.length; i += chunkSize) {
                  tokenChunks.push(token.substring(i, i + chunkSize));
                }

                const claims = {
                  agent_first_name: puzzelInfoData["agent.firstName"],
                  agent_last_name: puzzelInfoData["agent.lastName"],
                  puzzel_token_parts: tokenChunks.length.toString()
                };

                tokenChunks.forEach((chunk, index) => {
                  claims[`puzzel_token_${index + 1}`] = chunk;
                });

                window.pzl.api.setClaims(claims);
              }

              // Start token check interval
              setInterval(refreshPuzzelToken, TOKEN_CHECK_INTERVAL_MS);
              console.log("Token check scheduled every 5 minutes (updates only when changed)");

              // Expose refresh function globally for manual testing
              window.refreshPuzzelToken = refreshPuzzelToken;

              // Refresh token when chat close/reload button is clicked
              document.addEventListener("click", function(e) {
                const target = e.target.closest("#Icon_close, [title='Close chat']");
                if (target) {
                  console.log("Chat close/reload detected, refreshing token...");
                  refreshPuzzelToken(true); // Force update
                }
              }, true);

              if (!widgetLoadError) {
                statusEl.textContent = "Ready!";
                setTimeout(() => {
                  loadingOverlay.classList.add("fade-out");
                  setTimeout(() => {
                    loadingOverlay.style.display = "none";
                  }, 500);
                }, 300);
              }

              window.addEventListener("resize", () => {
                if (window.pzl && window.pzl.api && typeof window.pzl.api.resize === "function") {
                  window.pzl.api.resize();
                }
              });
            }
          }, 100);

          setTimeout(() => {
            if (!puzzelInitialized) {
              clearInterval(checkPzlReady);
              console.error = originalConsoleError;
              if (!widgetLoadError) {
                statusEl.textContent = "Initialization taking longer than expected...";
              }
            }
          }, 10000);
        };

        loader.onerror = function () {
          statusEl.textContent = "Error: Failed to load Puzzel chat widget loader.";
        };

        document.body.appendChild(loader);

      } catch (error) {
        console.error("Puzzel-only flow failed:", error);
        statusEl.textContent = "Connection Error";
        const subtext = document.querySelector(".status-subtext");
        if (subtext) {
          subtext.textContent = "This page must be opened inside Puzzel";
        }
      }
    }

    main();

    setTimeout(() => {
      if (!puzzelInitialized) {
        statusEl.textContent = "Unable to connect";
        const subtext = document.querySelector(".status-subtext");
        if (subtext) {
          subtext.textContent = "This page must be opened inside the Puzzel app";
        }
      }
    }, 12000);
  })();
  </script>
</body>
</html>

